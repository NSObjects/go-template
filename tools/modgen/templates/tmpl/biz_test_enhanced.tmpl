/*
 * Generated enhanced test cases from OpenAPI3 document
 * Module: {{.Pascal}}
 * Features: Comprehensive table-driven tests with validation coverage
 */

package biz

import (
	{{if .Operations}}"context"
	"testing"
	{{if .HasTimeFields}}"time"
	{{end}}"{{.PackagePath}}/internal/api/data"
	"{{.PackagePath}}/internal/api/service/param"
	{{if .HasRequestBodyOrQuery}}"github.com/go-playground/validator/v10"
	{{end}}"github.com/stretchr/testify/assert"{{end}}
)

{{if .Operations}}
{{range .Operations}}
{{$methodName := .MethodName}}
{{$requestBody := .RequestBody}}
func Test{{$.Pascal}}Handler_{{.MethodName}}(t *testing.T) {
	tests := []struct {
		name        string
		setupData   func() (context.Context{{if .HasPathParams}}, int64{{end}}{{if .HasRequestBodyOrQuery}}, param.{{$.Pascal}}{{.MethodName}}Request{{end}})
		expectError bool
		errorMsg    string
		validateResult func(t *testing.T{{if and .ResponseData (eq .ResponseData.GoType "Data")}}, result *param.{{$.Pascal}}Data{{end}}{{if and .ResponseData (eq .ResponseData.GoType "ListItem")}}, result []param.{{$.Pascal}}ListItem, total int64{{end}})
	}{
		{
			name: "成功场景",
			setupData: func() (context.Context{{if .HasPathParams}}, int64{{end}}{{if .HasRequestBodyOrQuery}}, param.{{$.Pascal}}{{.MethodName}}Request{{end}}) {
				ctx := context.Background()
				{{if .HasPathParams}}id := int64(1){{end}}
				{{if .HasRequestBodyOrQuery}}req := param.{{$.Pascal}}{{.MethodName}}Request{
					{{if .RequestBody}}
					{{range .RequestBody.Fields}}
					{{.FieldName}}: {{if eq .GoType "string"}}"test{{.FieldName}}"{{else if eq .GoType "int" "int64"}}1{{else if eq .GoType "float64"}}1.0{{else if eq .GoType "bool"}}true{{else if eq .GoType "time.Time"}}time.Now(){{else}}nil{{end}},
					{{end}}
					{{else}}
					{{range .QueryParameters}}
					{{.FieldName}}: {{if eq .GoType "string"}}"test{{.FieldName}}"{{else if eq .GoType "int" "int64"}}1{{else if eq .GoType "float64"}}1.0{{else if eq .GoType "bool"}}true{{else if eq .GoType "time.Time"}}time.Now(){{else}}nil{{end}},
					{{end}}
					{{end}}
				}{{end}}
				return ctx{{if .HasPathParams}}, id{{end}}{{if .HasRequestBodyOrQuery}}, req{{end}}
			},
			expectError: false,
			validateResult: func(t *testing.T{{if and .ResponseData (eq .ResponseData.GoType "Data")}}, result *param.{{$.Pascal}}Data{{end}}{{if and .ResponseData (eq .ResponseData.GoType "ListItem")}}, result []param.{{$.Pascal}}ListItem, total int64{{end}}) {
				{{if and .ResponseData (eq .ResponseData.GoType "Data")}}
				assert.Nil(t, result) // 当前实现返回nil
				{{else if and .ResponseData (eq .ResponseData.GoType "ListItem")}}
				assert.Nil(t, result)
				assert.Equal(t, int64(0), total)
				{{end}}
			},
		},
		{{if .HasPathParams}}
		{
			name: "无效ID",
			setupData: func() (context.Context{{if .HasPathParams}}, int64{{end}}{{if .HasRequestBodyOrQuery}}, param.{{$.Pascal}}{{.MethodName}}Request{{end}}) {
				ctx := context.Background()
				id := int64(0) // 无效ID
				{{if .HasRequestBodyOrQuery}}req := param.{{$.Pascal}}{{.MethodName}}Request{}{{end}}
				return ctx{{if .HasPathParams}}, id{{end}}{{if .HasRequestBodyOrQuery}}, req{{end}}
			},
			expectError: false, // 当前实现不会返回错误
			validateResult: func(t *testing.T{{if and .ResponseData (eq .ResponseData.GoType "Data")}}, result *param.{{$.Pascal}}Data{{end}}{{if and .ResponseData (eq .ResponseData.GoType "ListItem")}}, result []param.{{$.Pascal}}ListItem, total int64{{end}}) {
				{{if and .ResponseData (eq .ResponseData.GoType "Data")}}
				assert.Nil(t, result)
				{{else if and .ResponseData (eq .ResponseData.GoType "ListItem")}}
				assert.Nil(t, result)
				assert.Equal(t, int64(0), total)
				{{end}}
			},
		},
		{{end}}
		{{if .HasRequestBodyOrQuery}}
		{
			name: "空请求参数",
			setupData: func() (context.Context{{if .HasPathParams}}, int64{{end}}{{if .HasRequestBodyOrQuery}}, param.{{$.Pascal}}{{.MethodName}}Request{{end}}) {
				ctx := context.Background()
				{{if .HasPathParams}}id := int64(1){{end}}
				req := param.{{$.Pascal}}{{$methodName}}Request{} // 空请求
				return ctx{{if .HasPathParams}}, id{{end}}, req
			},
			expectError: false, // 当前实现不会返回错误
			validateResult: func(t *testing.T{{if and .ResponseData (eq .ResponseData.GoType "Data")}}, result *param.{{$.Pascal}}Data{{end}}{{if and .ResponseData (eq .ResponseData.GoType "ListItem")}}, result []param.{{$.Pascal}}ListItem, total int64{{end}}) {
				{{if and .ResponseData (eq .ResponseData.GoType "Data")}}
				assert.Nil(t, result)
				{{else if and .ResponseData (eq .ResponseData.GoType "ListItem")}}
				assert.Nil(t, result)
				assert.Equal(t, int64(0), total)
				{{end}}
			},
		},
		{{end}}
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// 创建handler
			handler := &{{$.Pascal}}Handler{
				dataManager: &data.DataManager{},
			}

			// 设置测试数据
			{{if and .HasPathParams .HasRequestBodyOrQuery}}
			ctx, id, req := tt.setupData()
			{{else if .HasPathParams}}
			ctx, id := tt.setupData()
			{{else if .HasRequestBodyOrQuery}}
			ctx, req := tt.setupData()
			{{else}}
			ctx := tt.setupData()
			{{end}}

			// 执行测试
			{{if and .ResponseData (eq .ResponseData.GoType "Data")}}
			{{if and .HasPathParams .HasRequestBodyOrQuery}}result, err := handler.{{.MethodName}}(ctx, id, req){{else if .HasPathParams}}result, err := handler.{{.MethodName}}(ctx, id){{else if .HasRequestBodyOrQuery}}result, err := handler.{{.MethodName}}(ctx, req){{else}}result, err := handler.{{.MethodName}}(ctx){{end}}
			{{else if and .ResponseData (eq .ResponseData.GoType "ListItem")}}
			{{if and .HasPathParams .HasRequestBodyOrQuery}}result, total, err := handler.{{.MethodName}}(ctx, id, req){{else if .HasPathParams}}result, total, err := handler.{{.MethodName}}(ctx, id){{else if .HasRequestBodyOrQuery}}result, total, err := handler.{{.MethodName}}(ctx, req){{else}}result, total, err := handler.{{.MethodName}}(ctx){{end}}
			{{else}}
			{{if and .HasPathParams .HasRequestBodyOrQuery}}err := handler.{{.MethodName}}(ctx, id, req){{else if .HasPathParams}}err := handler.{{.MethodName}}(ctx, id){{else if .HasRequestBodyOrQuery}}err := handler.{{.MethodName}}(ctx, req){{else}}err := handler.{{.MethodName}}(ctx){{end}}
			{{end}}

			// 验证结果
			if tt.expectError {
				assert.Error(t, err)
				if tt.errorMsg != "" {
					assert.Contains(t, err.Error(), tt.errorMsg)
				}
			} else {
				assert.NoError(t, err)
			}

			// 验证返回值
			if tt.validateResult != nil {
				{{if and .ResponseData (eq .ResponseData.GoType "Data")}}
				tt.validateResult(t, result)
				{{else if and .ResponseData (eq .ResponseData.GoType "ListItem")}}
				tt.validateResult(t, result, total)
				{{else}}
				tt.validateResult(t)
				{{end}}
			}
		})
	}
}

{{if .HasRequestBodyOrQuery}}
func Test{{$.Pascal}}Handler_{{$methodName}}_Validation(t *testing.T) {
	tests := []struct {
		name        string
		setupReq    func() param.{{$.Pascal}}{{$methodName}}Request
		expectError bool
		errorFields []string
	}{
		{{if .RequestBody}}
		{
			name: "有效请求数据",
			setupReq: func() param.{{$.Pascal}}{{$methodName}}Request {
				return param.{{$.Pascal}}{{$methodName}}Request{
					{{range .RequestBody.Fields}}
					{{if .Required}}
					{{.FieldName}}: {{if eq .GoType "string"}}"valid{{.FieldName}}"{{else if eq .GoType "int" "int64"}}1{{else if eq .GoType "float64"}}1.0{{else if eq .GoType "bool"}}true{{else if eq .GoType "time.Time"}}time.Now(){{else}}nil{{end}},
					{{end}}
					{{end}}
				}
			},
			expectError: false,
		},
		{{range .RequestBody.Fields}}
		{{$currentField := .}}
		{{if .Required}}
		{
			name: "缺少必填字段_{{.FieldName}}",
			setupReq: func() param.{{$.Pascal}}{{$methodName}}Request {
				req := param.{{$.Pascal}}{{$methodName}}Request{
					{{range $requestBody.Fields}}
					{{if and .Required (ne .Name $currentField.Name)}}
					{{.FieldName}}: {{if eq .GoType "string"}}"valid{{.FieldName}}"{{else if eq .GoType "int" "int64"}}1{{else if eq .GoType "float64"}}1.0{{else if eq .GoType "bool"}}true{{else if eq .GoType "time.Time"}}time.Now(){{else}}nil{{end}},
					{{end}}
					{{end}}
				}
				// {{.FieldName}}字段保持零值
				return req
			},
			expectError: true,
			errorFields: []string{"{{.FieldName}}"},
		},
		{{end}}
		{{end}}
		{{range .RequestBody.Fields}}
		{{$currentField := .}}
		{{if .ValidationRules}}
		{
			name: "{{.FieldName}}验证失败",
			setupReq: func() param.{{$.Pascal}}{{$methodName}}Request {
				return param.{{$.Pascal}}{{$methodName}}Request{
					{{range $requestBody.Fields}}
					{{if ne .Name $currentField.Name}}
					{{.FieldName}}: {{if eq .GoType "string"}}"valid{{.FieldName}}"{{else if eq .GoType "int" "int64"}}1{{else if eq .GoType "float64"}}1.0{{else if eq .GoType "bool"}}true{{else if eq .GoType "time.Time"}}time.Now(){{else}}nil{{end}},
					{{end}}
					{{end}}
					{{.FieldName}}: {{if eq .GoType "string"}}{{if contains .ValidationRules "min"}}"a"{{else if contains .ValidationRules "email"}}"invalid-email"{{else}}"invalid"{{end}}{{else if eq .GoType "int" "int64"}}-1{{else if eq .GoType "float64"}}-1.0{{else if eq .GoType "bool"}}false{{else}}nil{{end}}, // 无效值
				}
			},
			expectError: true,
			errorFields: []string{"{{.FieldName}}"},
		},
		{{end}}
		{{end}}
		{{else}}
		{
			name: "有效分页参数",
			setupReq: func() param.{{$.Pascal}}{{$methodName}}Request {
				return param.{{$.Pascal}}{{$methodName}}Request{
					{{range .QueryParameters}}
					{{.FieldName}}: {{if eq .GoType "string"}}"test{{.FieldName}}"{{else if eq .GoType "int" "int64"}}1{{else if eq .GoType "float64"}}1.0{{else if eq .GoType "bool"}}true{{else if eq .GoType "time.Time"}}time.Now(){{else}}nil{{end}},
					{{end}}
				}
			},
			expectError: false,
		},
		{
			name: "无效页码",
			setupReq: func() param.{{$.Pascal}}{{$methodName}}Request {
				return param.{{$.Pascal}}{{$methodName}}Request{
					{{range .QueryParameters}}
					{{.FieldName}}: {{if eq .GoType "string"}}"invalid{{.FieldName}}"{{else if eq .GoType "int" "int64"}}0{{else if eq .GoType "float64"}}0.0{{else if eq .GoType "bool"}}false{{else if eq .GoType "time.Time"}}time.Now(){{else}}nil{{end}},
					{{end}}
				}
			},
			expectError: true,
			errorFields: []string{"Page"},
		},
		{
			name: "页面大小超出限制",
			setupReq: func() param.{{$.Pascal}}{{$methodName}}Request {
				return param.{{$.Pascal}}{{$methodName}}Request{
					{{range .QueryParameters}}
					{{.FieldName}}: {{if eq .GoType "string"}}"invalid{{.FieldName}}"{{else if eq .GoType "int" "int64"}}101{{else if eq .GoType "float64"}}101.0{{else if eq .GoType "bool"}}false{{else if eq .GoType "time.Time"}}time.Now(){{else}}nil{{end}},
					{{end}}
				}
			},
			expectError: true,
			errorFields: []string{"Size"},
		},
		{{end}}
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// 创建validator
			validator := validator.New()

			// 设置测试数据
			req := tt.setupReq()

			// 执行验证
			err := validator.Struct(req)

			// 验证结果
			if tt.expectError {
				assert.Error(t, err, "期望验证失败")
				if len(tt.errorFields) > 0 {
					// 检查是否包含期望的错误字段
					for _, field := range tt.errorFields {
						assert.Contains(t, err.Error(), field, "错误信息应包含字段: %s", field)
					}
				}
			} else {
				assert.NoError(t, err, "期望验证通过")
			}
		})
	}
}
{{end}}

{{if .HasPathParams}}
func Test{{$.Pascal}}Handler_{{$methodName}}_PathParams(t *testing.T) {
	tests := []struct {
		name        string
		id          int64
		expectError bool
		errorMsg    string
	}{
		{
			name:        "有效ID",
			id:          1,
			expectError: false,
		},
		{
			name:        "零ID",
			id:          0,
			expectError: false, // 当前实现不会返回错误
		},
		{
			name:        "负数ID",
			id:          -1,
			expectError: false, // 当前实现不会返回错误
		},
		{
			name:        "大ID",
			id:          999999,
			expectError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// 创建handler
			handler := &{{$.Pascal}}Handler{
				dataManager: &data.DataManager{},
			}

			ctx := context.Background()
			{{if .HasRequestBodyOrQuery}}req := param.{{$.Pascal}}{{.MethodName}}Request{}{{end}}

			// 执行测试
			{{if and .ResponseData (eq .ResponseData.GoType "Data")}}
			{{if .HasRequestBodyOrQuery}}result, err := handler.{{.MethodName}}(ctx, tt.id, req){{else}}result, err := handler.{{.MethodName}}(ctx, tt.id){{end}}
			{{else if and .ResponseData (eq .ResponseData.GoType "ListItem")}}
			{{if .HasRequestBodyOrQuery}}result, total, err := handler.{{.MethodName}}(ctx, tt.id, req){{else}}result, total, err := handler.{{.MethodName}}(ctx, tt.id){{end}}
			{{else}}
			{{if .HasRequestBodyOrQuery}}err := handler.{{.MethodName}}(ctx, tt.id, req){{else}}err := handler.{{.MethodName}}(ctx, tt.id){{end}}
			{{end}}

			// 验证结果
			if tt.expectError {
				assert.Error(t, err)
				if tt.errorMsg != "" {
					assert.Contains(t, err.Error(), tt.errorMsg)
				}
			} else {
				assert.NoError(t, err)
			}

			// 验证返回值
			{{if and .ResponseData (eq .ResponseData.GoType "Data")}}
			assert.Nil(t, result) // 当前实现返回nil
			{{else if and .ResponseData (eq .ResponseData.GoType "ListItem")}}
			assert.Nil(t, result)
			assert.Equal(t, int64(0), total)
			{{end}}
		})
	}
}
{{end}}

{{if .HasRequestBodyOrQuery}}
func Test{{$.Pascal}}Handler_{{$methodName}}_EdgeCases(t *testing.T) {
	tests := []struct {
		name        string
		setupReq    func() param.{{$.Pascal}}{{$methodName}}Request
		description string
	}{
		{{if .RequestBody}}
		{
			name: "边界值测试_最小长度",
			setupReq: func() param.{{$.Pascal}}{{$methodName}}Request {
				return param.{{$.Pascal}}{{$methodName}}Request{
					{{range .RequestBody.Fields}}
					{{if eq .GoType "string"}}
					{{.FieldName}}: "a", // 最小长度
					{{else}}
					{{.FieldName}}: {{if eq .GoType "int" "int64"}}1{{else if eq .GoType "float64"}}1.0{{else if eq .GoType "bool"}}true{{else if eq .GoType "time.Time"}}time.Now(){{else}}nil{{end}},
					{{end}}
					{{end}}
				}
			},
			description: "测试字符串字段的最小长度",
		},
		{
			name: "边界值测试_最大长度",
			setupReq: func() param.{{$.Pascal}}{{$methodName}}Request {
				return param.{{$.Pascal}}{{$methodName}}Request{
					{{range .RequestBody.Fields}}
					{{if eq .GoType "string"}}
					{{.FieldName}}: "a", // 这里应该根据实际的最大长度设置
					{{else}}
					{{.FieldName}}: {{if eq .GoType "int" "int64"}}1{{else if eq .GoType "float64"}}1.0{{else if eq .GoType "bool"}}true{{else if eq .GoType "time.Time"}}time.Now(){{else}}nil{{end}},
					{{end}}
					{{end}}
				}
			},
			description: "测试字符串字段的最大长度",
		},
		{{else}}
		{
			name: "边界值测试_最小分页",
			setupReq: func() param.{{$.Pascal}}{{$methodName}}Request {
				return param.{{$.Pascal}}{{$methodName}}Request{
					{{range .QueryParameters}}
					{{.FieldName}}: {{if eq .GoType "string"}}"boundary{{.FieldName}}"{{else if eq .GoType "int" "int64"}}1{{else if eq .GoType "float64"}}1.0{{else if eq .GoType "bool"}}true{{else if eq .GoType "time.Time"}}time.Now(){{else}}nil{{end}},
					{{end}}
				}
			},
			description: "测试最小分页参数",
		},
		{
			name: "边界值测试_最大分页",
			setupReq: func() param.{{$.Pascal}}{{$methodName}}Request {
				return param.{{$.Pascal}}{{$methodName}}Request{
					{{range .QueryParameters}}
					{{.FieldName}}: {{if eq .GoType "string"}}"max{{.FieldName}}"{{else if eq .GoType "int" "int64"}}100{{else if eq .GoType "float64"}}100.0{{else if eq .GoType "bool"}}true{{else if eq .GoType "time.Time"}}time.Now(){{else}}nil{{end}},
					{{end}}
				}
			},
			description: "测试最大分页参数",
		},
		{{end}}
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// 创建handler
			handler := &{{$.Pascal}}Handler{
				dataManager: &data.DataManager{},
			}

			ctx := context.Background()
			{{if .HasPathParams}}id := int64(1){{end}}
			req := tt.setupReq()

			// 执行测试
			{{if and .ResponseData (eq .ResponseData.GoType "Data")}}
			{{if .HasPathParams}}result, err := handler.{{.MethodName}}(ctx, id, req){{else}}result, err := handler.{{.MethodName}}(ctx, req){{end}}
			{{else if and .ResponseData (eq .ResponseData.GoType "ListItem")}}
			{{if .HasPathParams}}result, total, err := handler.{{.MethodName}}(ctx, id, req){{else}}result, total, err := handler.{{.MethodName}}(ctx, req){{end}}
			{{else}}
			{{if .HasPathParams}}err := handler.{{.MethodName}}(ctx, id, req){{else}}err := handler.{{.MethodName}}(ctx, req){{end}}
			{{end}}

			// 验证结果
			assert.NoError(t, err, tt.description)

			// 验证返回值
			{{if and .ResponseData (eq .ResponseData.GoType "Data")}}
			assert.Nil(t, result)
			{{else if and .ResponseData (eq .ResponseData.GoType "ListItem")}}
			assert.Nil(t, result)
			assert.Equal(t, int64(0), total)
			{{end}}
		})
	}
}
{{end}}

{{end}}
{{end}}