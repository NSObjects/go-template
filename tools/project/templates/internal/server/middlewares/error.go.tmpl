package middlewares

import (
	"fmt"
	"log/slog"
	"net/http"
	"time"

	"{{.ModulePath}}/internal/code"
	"{{.ModulePath}}/internal/log"
	"{{.ModulePath}}/internal/resp"
	"github.com/labstack/echo/v4"
	"github.com/marmotedu/errors"
)

// ErrorHandler 增强的错误处理器
func ErrorHandler(err error, c echo.Context) {
	// 记录错误开始时间
	start := time.Now()

	// 记录所有错误信息用于调试
	log.Debug("Error received",
		slog.String("error", err.Error()),
		slog.String("type", fmt.Sprintf("%T", err)),
	)

	// 检查是否是业务错误
	if codeError := errors.ParseCoder(err); codeError != nil {
		log.Debug("Business error detected",
			slog.Int("code", codeError.Code()),
		)
	} else {
		log.Debug("No business error code found")
	}

	// 处理不同类型的错误
	switch e := err.(type) {
	case *echo.HTTPError:
		log.Debug("HTTP Error detected")
		handleHTTPError(e, c)
	case *ValidationError:
		log.Debug("Validation Error detected")
		handleValidationError(e, c)
	default:
		// 其他错误
		handleGenericError(err, c)
	}

	// 记录处理时间
	duration := time.Since(start)
	log.Debug("Error handled",
		slog.Duration("duration", duration),
		slog.String("method", c.Request().Method),
		slog.String("uri", c.Request().RequestURI),
	)
}

// ValidationError 验证错误
type ValidationError struct {
	Field   string      `json:"field"`
	Message string      `json:"message"`
	Value   interface{} `json:"value,omitempty"`
}

func (e *ValidationError) Error() string {
	return e.Message
}

// handleHTTPError 处理HTTP错误
func handleHTTPError(err *echo.HTTPError, c echo.Context) {
	// 将Echo HTTP错误转换为业务错误
	var bizErr error
	message := extractErrorMessage(err.Message)
	switch err.Code {
	case http.StatusBadRequest:
		bizErr = errors.WithCode(code.ErrBadRequest, "%s", message)
	case http.StatusUnauthorized:
		bizErr = errors.WithCode(code.ErrUnauthorized, "%s", message)
	case http.StatusForbidden:
		bizErr = errors.WithCode(code.ErrForbidden, "%s", message)
	case http.StatusNotFound:
		bizErr = errors.WithCode(code.ErrNotFound, "%s", message)
	default:
		bizErr = errors.WithCode(code.ErrInternalServer, "%s", message)
	}

	// 返回标准错误响应
	_ = resp.APIError(bizErr, c)
}

// handleValidationError 处理验证错误
func handleValidationError(err *ValidationError, c echo.Context) {
	// 记录验证错误
	log.Warn("Validation Error",
		slog.String("field", err.Field),
		slog.String("message", err.Message),
		slog.Any("value", err.Value),
		slog.String("method", c.Request().Method),
		slog.String("uri", c.Request().RequestURI),
	)

	// 创建业务错误
	bizErr := code.NewValidationError(err.Field, err.Message)
	_ = resp.APIError(bizErr, c)
}

// handleGenericError 处理通用错误
func handleGenericError(err error, c echo.Context) {
	if codeError := errors.ParseCoder(err); codeError != nil {
		log.Debug("Business error detected",
			slog.Int("code", codeError.Code()),
			slog.String("error", err.Error()),
		)
		_ = resp.APIError(err, c)
		return
	}

	// 记录通用错误并返回标准化的内部错误响应
	log.Error("Generic Error",
		slog.String("error", err.Error()),
		slog.String("method", c.Request().Method),
		slog.String("uri", c.Request().RequestURI),
	)

	wrapped := code.WrapInternalServerError(err, "internal server error")
	_ = resp.APIError(wrapped, c)
}

// extractErrorMessage 将 Echo 错误消息转换为字符串
func extractErrorMessage(message interface{}) string {
	switch v := message.(type) {
	case string:
		return v
	case error:
		return v.Error()
	default:
		return fmt.Sprint(v)
	}
}

// ErrorRecovery 错误恢复中间件
func ErrorRecovery() echo.MiddlewareFunc {
	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			defer func() {
				if r := recover(); r != nil {
					// 记录panic信息
					log.Error("Panic recovered",
						slog.Any("panic", r),
						slog.String("method", c.Request().Method),
						slog.String("uri", c.Request().RequestURI),
					)

					// 创建内部服务器错误
					err := errors.WithCode(100500, "internal server error")
					_ = resp.APIError(err, c)
				}
			}()

			return next(c)
		}
	}
}